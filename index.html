<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Köppen-Geiger Globe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;700;900&display=swap" rel="stylesheet">

  <style>
    html, body,
    #controlWrapper,
    .toggle-button,
    #opacityControls,
    #legendContainer,
    input[type=range],
    .mapboxgl-ctrl,
    .mapboxgl-popup-content {
      font-family: 'Ubuntu', sans-serif !important;
    }

    .mapboxgl-popup-content a {
      display: block;
      text-decoration: none;
      color: inherit;
      width: 100%;
      height: 100%;
    }

    html, body { margin: 0; padding: 0; height: 100%; }
    #map { width: 100%; height: 100%; }

    #controlWrapper {
      position: absolute;
      top: 70px;
      left: 10px;
      background: white;
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 0 6px rgba(0,0,0,0.15);
      z-index: 1000;
      max-width: 300px;
    }

    .toggle-button {
      display: block;
      cursor: pointer;
      background: none;
      border: none;
      font-size: 18px;
      width: fit-content;
      text-align: left;
      padding: 6px 0;
    }

    #opacityControls,
    #legendContainer {
      margin-top: 6px;
      display: none;
    }

    #legendContainer img {
      height: 40vh;
      width: auto;
      max-width: 100%;
      object-fit: contain;
      display: block;
      margin: 0 auto;
    }

    .popup-image {
      max-width: 100%;
      max-height: 150px;
      display: block;
      margin-top: 6px;
    }

    .zone-text {
      line-height: 1.25;
      display: inline-block;
    }

    .zone-text.stroke {
      -webkit-text-stroke: 0.35px rgba(0,0,0,0.85);
      text-shadow:
        0.3px 0 0 rgba(0,0,0,0.85),
        -0.3px 0 0 rgba(0,0,0,0.85),
        0 0.3px 0 rgba(0,0,0,0.85),
        0 -0.3px 0 rgba(0,0,0,0.85),
        0.21px 0.21px 0 rgba(0,0,0,0.85),
        -0.21px 0.21px 0 rgba(0,0,0,0.85),
        0.21px -0.21px 0 rgba(0,0,0,0.85),
        -0.21px -0.21px 0 rgba(0,0,0,0.85);
    }

    /* Search UI */
    #searchBox {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 6px 10px;
      border-radius: 6px;
      box-shadow: 0 0 6px rgba(0,0,0,0.15);
      z-index: 1500;
      width: 230px;
    }

    #searchInput {
      width: 100%;
      border: none;
      outline: none;
      font-size: 14px;
    }

    #searchSuggestions {
      margin-top: 4px;
      max-height: 200px;
      overflow-y: auto;
      border-radius: 4px;
      box-shadow: 0 0 4px rgba(0,0,0,0.15);
      background: white;
      display: none;
    }

    .suggestion-item {
      padding: 6px 8px;
      cursor: pointer;
      font-size: 13px;
      border-bottom: 1px solid #eee;
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-item:hover {
      background: #f2f2f2;
    }

    .suggestion-item.disabled {
      cursor: default;
      color: #999;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="searchBox">
    <input id="searchInput" placeholder="Search place…" autocomplete="off">
    <div id="searchSuggestions"></div>
  </div>

  <div id="controlWrapper">
    <button id="toggleOpacity" class="toggle-button">Show Climate</button>

    <div id="opacityControls">
      <label style="font-size:14px;">Climate opacity</label>
      <input type="range" id="climateSlider" min="0" max="1" step="0.05" value="0.25">
    </div>

    <button id="toggleLegend" class="toggle-button">Show Legend</button>
    <div id="legendContainer">
      <img src="./legend.jpg" alt="Climate Zones Legend">
    </div>
  </div>

  <script>
    function hexToRgb(hex) {
      if (!hex) return null;
      let c = hex.trim();
      if (c[0] === '#') c = c.slice(1);
      if (c.length === 3) c = c.split('').map(ch => ch + ch).join('');
      if (c.length !== 6 || /[^0-9a-f]/i.test(c)) return null;
      const num = parseInt(c, 16);
      return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
    }

    function brightnessFromHex(hex) {
      const rgb = hexToRgb(hex);
      if (!rgb) return 0.5;
      const { r, g, b } = rgb;
      return ((r * 299) + (g * 587) + (b * 114)) / (255000);
    }

    const BRIGHTNESS_THRESHOLD = 0.75;

    function createGeoJSONCircle(center, radiusKm, points = 64) {
      const lat = center[1], lon = center[0];
      const coords = [];
      const dX = radiusKm / (111.32 * Math.cos(lat * Math.PI / 180));
      const dY = radiusKm / 110.574;
      for (let i = 0; i < points; i++) {
        const θ = 2 * Math.PI * i / points;
        coords.push([lon + dX * Math.cos(θ), lat + dY * Math.sin(θ)]);
      }
      coords.push(coords[0]);
      return { type: 'Feature', geometry: { type: 'Polygon', coordinates: [coords] } };
    }

    mapboxgl.accessToken =
      'pk.eyJ1IjoiYXJjaHdydGgiLCJhIjoiY21hZHZpb3Y0MDB3czJxcjZxNjMyNjV5ayJ9.Z5pVSBUcI3HDeALtF6YIiA';

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/satellite-streets-v12',
      projection: 'globe',
      zoom: 1.5,
      center: [39.271406, -7.046950]
    });

    map.on('style.load', () => map.setFog({}));

    map.on('load', () => {
      map.addSource('koppen', { type: 'geojson', data: './koppen.json' });
      map.addLayer({
        id: 'koppen-layer',
        type: 'fill',
        source: 'koppen',
        paint: { 'fill-color': ['get', 'fill'], 'fill-opacity': 0.25 }
      });

      // Load regular pins
      fetch('pins.json')
        .then(res => res.json())
        .then(points => {
          points.forEach(pt => {
            const coords = [pt.longitude, pt.latitude];

            let zoneLines = "";
            if (pt.zones && Array.isArray(pt.zones)) {
              zoneLines = pt.zones
                .map(z => {
                  const bright = brightnessFromHex(z.colour) >= BRIGHTNESS_THRESHOLD;
                  const cls = bright ? 'zone-text stroke' : 'zone-text';
                  return `<span class="${cls}" style="color:${z.colour};">${z.text}</span>`;
                })
                .join('<br>');
            }

            const popupHtml =
              `<a href="${pt.link}" target="_blank" rel="noopener noreferrer">` +
              `<div style="font-weight:700; text-align:center; font-size:17px; margin-bottom:4px;">${pt.title}</div>` +
              (pt.address ? `${pt.address}<br>` : '') +
              `${zoneLines}<br>` +
              (pt.gdpr ? '<em>Marked area is not exact.</em><br>' : '') +
              (pt.imageUrl
                ? `<div style="text-align:center;"><img class="popup-image" src="${pt.imageUrl}" /></div>`
                : '') +
              `</a>`;

            new mapboxgl.Marker({ color: '#FF0000' })
              .setLngLat(coords)
              .setPopup(new mapboxgl.Popup().setHTML(popupHtml))
              .addTo(map);

            if (pt.gdpr) {
              const circle = createGeoJSONCircle(coords, pt.radiusKm);
              const id = `circle-${pt.id}`;
              map.addSource(id, { type: 'geojson', data: circle });
              map.addLayer({
                id: `${id}-fill`,
                type: 'fill',
                source: id,
                paint: { 'fill-color': '#ffffff', 'fill-opacity': 0.15 }
              });
              map.addLayer({
                id: `${id}-line`,
                type: 'line',
                source: id,
                paint: { 'line-color': '#ffffff', 'line-width': 1 }
              });
            }
          });
        });

      // Load weather stations
      fetch('weather_stations.json')
        .then(res => res.json())
        .then(stations => {
          stations.forEach(st => {
            const coords = [st.longitude, st.latitude];

            let zoneLines = "";
            if (st.zones && Array.isArray(st.zones)) {
              zoneLines = st.zones
                .map(z => {
                  const bright = brightnessFromHex(z.colour) >= BRIGHTNESS_THRESHOLD;
                  const cls = bright ? 'zone-text stroke' : 'zone-text';
                  return `<span class="${cls}" style="color:${z.colour};">${z.text}</span>`;
                })
                .join('<br>');
            }

            const popupHtml =
              `<a href="${st.link}" target="_blank" rel="noopener noreferrer">` +
              `<div style="font-weight:700; text-align:center; font-size:17px; margin-bottom:4px;">${st.title}</div>` +
              (st.address ? `${st.address}<br>` : '') +
              `${zoneLines}<br>` +
              (st.gdpr ? '<em>Marked area is not exact.</em><br>' : '') +
              (st.imageUrl
                ? `<div style="text-align:center;"><img class="popup-image" src="${st.imageUrl}" /></div>`
                : '') +
              `</a>`;

            // Create custom weather station marker
            const el = document.createElement('div');
            el.innerHTML = `
              <svg width="32" height="40" viewBox="0 0 32 40" xmlns="http://www.w3.org/2000/svg">
                <g filter="url(#shadow)">
                  <!-- Outer black stroke for contrast -->
                  <g stroke="#000000" stroke-width="3" fill="none">
                    <rect x="14" y="8" width="4" height="24"/>
                    <rect x="10" y="4" width="12" height="6" rx="1"/>
                    <circle cx="16" cy="7" r="1.5"/>
                    <rect x="8" y="15" width="16" height="2" rx="0.5"/>
                    <rect x="15" y="12" width="2" height="8" rx="0.5"/>
                    <circle cx="8" cy="16" r="2"/>
                    <circle cx="24" cy="16" r="2"/>
                    <path d="M 12 32 L 10 38 L 22 38 L 20 32 Z"/>
                    <ellipse cx="16" cy="32" rx="6" ry="2"/>
                  </g>
                  
                  <!-- Main yellow fill -->
                  <g stroke="#FFD700" stroke-width="1.5" fill="#FFD700">
                    <!-- Main pole -->
                    <rect x="14" y="8" width="4" height="24"/>
                    
                    <!-- Top sensor box -->
                    <rect x="10" y="4" width="12" height="6" rx="1"/>
                    <circle cx="16" cy="7" r="1.5" fill="#333333"/>
                    
                    <!-- Middle cross arms -->
                    <rect x="8" y="15" width="16" height="2" rx="0.5"/>
                    <rect x="15" y="12" width="2" height="8" rx="0.5"/>
                    
                    <!-- Small sensors on arms -->
                    <circle cx="8" cy="16" r="2" fill="#333333"/>
                    <circle cx="24" cy="16" r="2" fill="#333333"/>
                    
                    <!-- Base -->
                    <path d="M 12 32 L 10 38 L 22 38 L 20 32 Z" fill="#FFA500"/>
                    <ellipse cx="16" cy="32" rx="6" ry="2"/>
                  </g>
                </g>
                
                <!-- Shadow filter -->
                <defs>
                  <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                    <feDropShadow dx="0" dy="1" stdDeviation="1.5" flood-opacity="0.4"/>
                  </filter>
                </defs>
              </svg>
            `;
            el.style.cursor = 'pointer';
            
            new mapboxgl.Marker({ element: el, anchor: 'bottom', offset: [0, 0] })
              .setLngLat(coords)
              .setPopup(new mapboxgl.Popup({ offset: 25 }).setHTML(popupHtml))
              .addTo(map);

            if (st.gdpr) {
              const circle = createGeoJSONCircle(coords, st.radiusKm);
              const id = `circle-station-${st.id}`;
              map.addSource(id, { type: 'geojson', data: circle });
              map.addLayer({
                id: `${id}-fill`,
                type: 'fill',
                source: id,
                paint: { 'fill-color': '#4A90E2', 'fill-opacity': 0.15 }
              });
              map.addLayer({
                id: `${id}-line`,
                type: 'line',
                source: id,
                paint: { 'line-color': '#4A90E2', 'line-width': 1 }
              });
            }
          });
        })
        .catch(err => console.log('Weather stations file not found or error loading:', err));

      map.addControl(
        new mapboxgl.NavigationControl({ showCompass: false }),
        'top-right'
      );

      const climateSlider = document.getElementById('climateSlider');

      climateSlider.addEventListener('input', e => {
        const v = parseFloat(e.target.value);
        if (map.getLayer('koppen-layer')) {
          map.setPaintProperty('koppen-layer', 'fill-opacity', v);
        }
      });

      climateSlider.dispatchEvent(new Event('input'));
    });

    const searchInput = document.getElementById('searchInput');
    const suggestionsEl = document.getElementById('searchSuggestions');
    let searchTimeout = null;

    function clearSuggestions() {
      suggestionsEl.innerHTML = '';
      suggestionsEl.style.display = 'none';
    }

    function goToFeature(feature) {
      if (!feature.center) return;
      const [lon, lat] = feature.center;
      map.flyTo({ center: [lon, lat], zoom: 10 });

      if (window._searchMarker) window._searchMarker.remove();
      window._searchMarker = new mapboxgl.Marker({ color: '#ffcc00' })
        .setLngLat([lon, lat])
        .addTo(map);

      clearSuggestions();
    }

    async function fetchSuggestions(query) {
      const c = map.getCenter();
      const url =
        'https://api.mapbox.com/geocoding/v5/mapbox.places/' +
        encodeURIComponent(query) +
        `.json?access_token=${mapboxgl.accessToken}` +
        `&autocomplete=true&limit=5&proximity=${c.lng},${c.lat}`;

      const r = await fetch(url);
      const d = await r.json();
      return d.features || [];
    }

    async function handleSearchInput(value) {
      const q = value.trim();
      if (q.length < 3) {
        clearSuggestions();
        return;
      }

      const features = await fetchSuggestions(q);
      suggestionsEl.innerHTML = '';

      if (!features.length) {
        const div = document.createElement('div');
        div.className = 'suggestion-item disabled';
        div.textContent = 'No results';
        suggestionsEl.appendChild(div);
        suggestionsEl.style.display = 'block';
        return;
      }

      features.forEach(f => {
        const div = document.createElement('div');
        div.className = 'suggestion-item';
        div.textContent = f.place_name;
        div.addEventListener('click', () => {
          searchInput.value = f.text;
          goToFeature(f);
        });
        suggestionsEl.appendChild(div);
      });

      suggestionsEl.style.display = 'block';
    }

    searchInput.addEventListener('input', e => {
      if (searchTimeout) clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => handleSearchInput(e.target.value), 250);
    });

    searchInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const first = suggestionsEl.querySelector('.suggestion-item:not(.disabled)');
        if (first) first.click();
      }
    });

    document.getElementById('toggleOpacity').addEventListener('click', () => {
      const el = document.getElementById('opacityControls');
      el.style.display = el.style.display === 'block' ? 'none' : 'block';
    });

    document.getElementById('toggleLegend').addEventListener('click', () => {
      const el = document.getElementById('legendContainer');
      el.style.display = el.style.display === 'block' ? 'none' : 'block';
    });
  </script>
</body>
</html>
